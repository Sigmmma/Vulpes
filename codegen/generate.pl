#!/usr/bin/perl
#
# Vulpes (c) 2019 gbMichelle
#
# This program is free software under the GNU General Public License v3.0 or later. See LICENSE for more information.
#

use strict;
use warnings;
use File::Basename qw( dirname basename );
use File::Spec::Functions qw( catfile );
use File::Path qw( make_path );
use YAML::XS qw( LoadFile );

use lib dirname(__FILE__); # Include own directory
use CodeGen::Signature qw( yaml_signatures_to_cpp_definitions );

sub gen_header {
    my $name = shift;
qq{/*
 * Vulpes (c) 2019 gbMichelle
 *
 * This program is free software under the GNU General Public License v3.0 or later. See LICENSE for more information.
 *
 * WARNING, THIS FILE WAS AUTOGENERATED. To avoid getting your work overwritten, edit $name instead.
 */

};
}

my $input_file_count = scalar @ARGV;
my $i = 0;

foreach my $filename (@ARGV) {
    # Terminal output non-sense.
    $i++;
    my $progress = int(($i*100)/$input_file_count);
    printf "[%3d%s] Building CPP files for %s\n", $progress, "%", $filename;

    # Load yaml definition.
    my $file = LoadFile $filename;

    # Get path without file extension.
    my $output_stem = $filename;
    $output_stem =~ s/\.\w+$//;

    # Just the isolated name.
    my $name = basename $output_stem;

    # Get output directory and make it.
    my $dir = catfile catfile (dirname $output_stem), "generated";
    make_path $dir;

    # Open new source and headers for writing.
    open(OUTPUT_SRC,  ">".(catfile $dir, "$name.cpp"));
    open(OUTPUT_HEAD, ">".(catfile $dir, "$name.hpp"));

    # basename with yaml extension
    my $yaml_basename = basename($filename);

    my $license_header = gen_header $yaml_basename;

    print OUTPUT_SRC $license_header, "#include <$output_stem.hpp>\n";
    print OUTPUT_HEAD $license_header, "#pragma once\n";

    # Writes all cpp data to the opened files.
    # TODO: Update this when more types of things get written to these.
    if (exists $file->{signatures}) {
        my $output = yaml_signatures_to_cpp_definitions $name, $file->{signatures};
        print OUTPUT_SRC join "\n", @{$output->{source}->{std_includes}}, "\n";
        print OUTPUT_SRC join "\n", @{$output->{source}->{includes}}, "\n";
        print OUTPUT_SRC $output->{source}->{defs};
        print OUTPUT_SRC $output->{source}->{initializer};

        print OUTPUT_HEAD join "\n", @{$output->{header}->{std_includes}}, "\n";
        print OUTPUT_HEAD join "\n", @{$output->{header}->{includes}}, "\n";
        print OUTPUT_HEAD $output->{header}->{defs};
        print OUTPUT_HEAD $output->{header}->{initializer};
    }

    close(OUTPUT_SRC);
    close(OUTPUT_HEAD);
};
